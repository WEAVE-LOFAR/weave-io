
Choose product for implicit addresses first by distance then by amount processed
Each arrow implies that the output can be formed by other inputs of the same type

### Addresses
	Address(color=['red', 'blue', 'green'])  # logical or
	Address(color='red') | Address(color='blue') | Address(color='green')  # logical or
	Address(color='red') & Address(color='blue') & Address(color='green')  # logical and

	Address(color='red') & Address(resolution='H') == Address(color='red', resolution='H')
	Address(color=['red', 'blue']) | Address(color=['red', 'green'])
	Address(color=['red', 'blue'], resolution=['H', 'L'])

### access the supertarget spectra (follow arrows)
	target = data[Address(target=targetname)]
	target.spectra  # implicitly supertarget spectra 
	target.supertargets.spectra  # explicitly
	target.singles.spectra  # can follow the arrows to singles

### access stack spectra (follow arrows)
	obspec = data[Address(obid=obid)].obspec
	obspec.spectra  # implicitly stacked spectra 
	obspec.stacks.spectra  # explicitly stacked
	obspec.singles.spectra
	obspec.raws.spectra

### access superstack spectra (follow arrows)
	target.superstacks.spectra # implicitly superstack
	target.obspecs.superstacks.spectra  # explicit

### indexing runs
	ob.runs[runid]  # implicitly skip exposure
	ob.runs[Address(exposure=0)]['red']  # explicitly index by exposure and arm
	ob.runs[Address(arm='red')][0]  # other way round is allowed also, but the int index refers to the exposure number
	ob.exposures[0]['red']  # implicitly returns a run
	ob.arms['red'].exposures[0]  # this is forbidden, arms does not belong to the OB



### L2 singles
	# L2 singles are made by joining the two runs in an exposure, so you only need the exposure number
	ob.l2[0]  # can implicitly index since it is only dependent on exposure
	ob.exposures[0].l2
	target.exposures.l2[Address(camera='red', ...)]

### L2 stacks/superstacks
# since l2 can be made from stacks and superstacks at once, there are multiple paths
# index by logical and
	target.OBs.l2[Address(color='red', resolution='H') & Address(color='blue', resolution='H')]
# index specifying only stacked
	target.OBs.stacks.l2[Address(color='red', resolution='H') & Address(color='blue', resolution)]


### L2 supertargets
# L2 supertargets are combinations of L1 red and blue &/ green. 

# Can triangulate using the L1 files
	f1 = target.supertargets[Address(color='red', resolution='H')]
	f2 = target.supertargets[Address(color='blue', resolution='H')]
	f3 = target.supertargets[Address(color='green', resolution='H')]
	target.l2[f1 & f2 & f3]

# Can index from one l1 file
	supertarget = target.supertargets[Address(resolution='H', color='red')]
	supertarget.l2s[Address(resolution='H', color='green')]  # specify the other one
# can index by logical and 
	target.l2[Address(color='red', resolution='H') & Address(color='green', resolution='H')]



data.stacks[Address(runid=run.runid)]


data.stacks[Address(mode='MOS', arm='red')]