
a. data.runs[Address(vph=green, date_obs=####)].spectra
b. data.obs[obid].runs[Address(vph=green, date_obs=####)].spectra

Chaining expressions:
	a. 
		* data.runs -> EclecticHomogeneousStore(Runs)
		* data.runs[Address(vph=green, date_obs=####)] -> EclecticHomogeneousStore(Runs, Address(vph=green, date_obs=####))
		* data.runs[Address(vph=green, date_obs=####)].spectrum -> Spectra
	b.
		* data.obs -> HomogeneousStore(OBs)
		* data.obs[obid] -> OB
		* data.obs[obid].runs -> HomogeneousStore(Runs, parents=[OB])
		* data.obs[obid].runs[Address(vph=green, date_obs=####)] -> HomogeneousStore(Runs, parents=[OB], Address(vph=green, date_obs=####))
		* data.obs[obid].runs[Address(vph=green, date_obs=####)].spectra -> Spectra
	At the end of chaining expressions, you have: 
		DataDirectory + [parent_ids(hierarchies)] + [address(factors)] + ProductType + [FileType] + Plural/Singular
specifying a `target` will filter to those which use this target
specifying a list of `target` will filter to those which use those targets




actions you can perform on the graph:
	* read(hierarchy_type, id, file_type) -> parent-factors, parent-hierarchies 
		- propgate backwards along arrows
		- Can only propgate forwards when all predecessors are known
	* 

data.runs[runid].l2superstacks
	* Read single file for all relevant factors 
	* Filter l2superstack fnames by those factors
	* Filter again by reading the l2superstack for ones that contain runid
	