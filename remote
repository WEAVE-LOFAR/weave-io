
Requirements: 
	1. Able to index local files and return indexed data products
	2. Able to index remote files and cache data products locally
	3. Able to index queries with logical arrays
		data.OBs[data.OBs.ids > 2]  # could be done "in graph"
		data.singles[propagate(data.singles.spectra()) < 5]  # data downloaded first and then indexed
		

Remote server may be updated at any time
Queries return {partial_file, }

Partial files: 
	Sometimes queries may index within a data file
	e.g. `data.l1.singles[Address(targetname=xxxx)].noss.spectra` 
	In this case we return a "Partial" file where only that the noss array for the targetname is return
	This is a much reduced file size
	Each time a partial read of the same file is downloaded, we stitch them together


Composite table/objects:
	When read into memory, a similar (same structure) spectra_block/table/etc is read into a master reference array.
	each spectra_block/table in a file is read. Only references are combined in the master array
	e.g.
		data[Address(camera='blue')].l1.spectra  # has attribute _subgraph, which can be indexed up or down
		data.l1single.spectra  # There are at least 2/3 different wavelength ranges so return DisjointSpectraBlock
							   # Must still be able to index that object data.l1single.spectra[Address(camera='')]


Local mode
	1. [User writes schema]
	2. [Index local files and add to local graph]
	3. Make query using query language
	4. Submit query to local graph
	5. Return `file[hdu][subindex]` or `Hierarchy object`
	6. If query returns file for which it only has partial references, request remote access



Remote mode
	1. Download schema 
	2. Make query using query language
	3. Submit query to remote graph 
	4. Return description of files to be downloaded
	5. Return (`partial_file(file[hdu][subindex])` or `Hierarchy object`, graph_update) which have not been cached yet
	6. Update local graph based on the graph_update  
		* `graph_update` contains the subgraph above the file[subindex]. 
		  Essentially, this tells the local graph that there is more to the file 
    7. Stitch any partial files together




When do we run the query?

data[address][key].file.product[index]

`data[address]` gives a query object
`ob = data[address]()` returns a Solid Hierarchy object
is ob.runs returned?

.factor(), returns value
.factors(), returns list(values)

.run/s(), returns the branch of factors/hierarchies related to these but not the physical data

.singles(), returns the branch and the files

.spectra(), returns product (and partial files)

.single.header[xxx], returns value
.singles.header[xxx], returns list(values)

"""
>>> singles = data[Address(camera='red')].singles
cypher(
	(:Factor:Camera {'name': red}))-[*]->(f:File:Single)
)
>>> data.superstacks[singles]
cypher(
	(:Factor:Camera {'name': red})-[*]->(:File:Single)-[:constructs]->(f:File:Superstack)
)

>>> data[Address(camera='red', )]

"""





Steps:
	* Transform input from networkx to neo4j
		- (Add constraints on uniqueness to all nodes)
		- Differentiate indexing/is_a/has_a links for querying 
	* Add query language []/.  -> cypher
	* Add local server response, {hierarchy, }