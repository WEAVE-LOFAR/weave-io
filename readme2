# WEAVE-IO

This code is intended to be one level above reading fits files and tables. 
There should be minimal manipulation at work here. 
Essentially, this is just a way to find and index data.
All of this design is up for discussion.

`weaveio` currently only supports local file-systems, but it can be readily expanded to handle remote queries, pulling only data the necessary data from a remote server. 


## Getting Started
`weaveio` only explores and indexes the data, there is no manipulation or joining of said data. Right now, we assume that you have the relevant data on your local machine.
To start indexing you instantiate the `Data` object in the data directory.
```python
from weaveio import Address, Data
data = Data('my_local_directory')
```
The `Data` object contains references to files, the data products within those files, and helpful structures like `OB` and `ArmConfig`.
The `Address` object is used to index simple information tags in the header files or FIBTABLE.
For example, `data[Address(camera='red')]` will return a query object that references only spectra/files/things which use the red arm of the weave spectrograph.
`data[Address(camera='red', target=cname01)]` will return a query object that references only spectra/files/things which use the red arm and observe the target `cname01`.

You can then access these files/spectra with idiomatic syntax:
```python
red = data[Address(camera='red')]
spectra_block = red.l1.single.spectra
```
`spectra_block` then contains all the single L1 red spectra on the same wavelength axis.

You can also access structures like OBs, Arm configurations, as well as files, spectra, and tables
```python
for ob in red.OBs:
	print(ob.obid)
```
`ob` is and `OB` object which contains information about the Observation Block such as `obid`, `startdate`, and anything else specifically relating to the OBS in the header of CASU output files.

## Hierarchies
`weaveio` not only queries files, but also structures that are present in the WEAVE data structure contained within those files (such as Observing Blocks, ProgTemps, and Runs). 
These objects are arranged in a hierarchy which describes which object belongs to which.
For example, an `OB` consists of multiple `Exposure`s which consist of two `Run`s (WEAVE defines a `Run` as a single image taken in a single arm).
Given this hierarchy, we can ask the questions: 

1. What is the `OB` that this `run` belongs to?
2. What `Run`s does this `ob` have?

In the language of `weaveio` these become:

1. `run.OB` - singular because a run will only ever have one parent OB
2. `ob.runs` - plural because an OB can consist of multiple runs

Some hierarchies such as `Run`, `OB`, `ObsTemp`, `ProgTemp`, and `ArmConfig` can be defined by their unique id.

* `data.runs[runid]`
* `data.obs[obid]`
* `data.ObsTemps[S|T|A|M|B]

Other hierarchies like the `OBSpec` (the submitted OB specification, not necessarily observed) can only be defined by an address:
* `data.OBs[obid].OBSpec` 
* `(data.ProgTemps[N|O|R|B|I] & data.ObsTemps[S|T|A|M|B]).OBSpecs`
* `data[Address(target=xxxx)].OBSpecs`

## Syntax
All queries are built using a combination of traversal `.thing` and filter `[<key>]` syntax.

### 1. Parent
`run.OB`

### 2. Children
`OB.runs`

### 3. Filter
`data[Address(vph=1, resolution='low')]`

### 4. ID
`data.runs[runid]`

### [5. Logical combination]
`(data.runs[runid1] & data.runs[runid2]).exposure`


## Delayed querying
None of the above returns actual data, the `.` and `[]` syntax only builds your query. 
To execute a query, simply call it with `()` on the end.
E.g.

`spectra = data[Address(vph=1, resolution='low')].l1.singles.spectra()`

## Combined data products
If a query expands beyond the range of single file (`data[Address(vph=1, camera='red')].l1.singles.spectra`), then the result is a combined data product.



## Subsequent indexing of data products


### List of available product types:
* Spectra - e.g. RED_NOSS, RED
* Table - e.g. FIBINFO


### List of file types

* Raw
* L1 Single 
* L1 Stack
* L1 Superstack
* L1 Supertarget
* L2 Single 
* L2 Stack/superstack
* L2 Supertarget


### List of hierarchies

* OBSpec
* OB
* Exposure
* Run
* ObsTemp
* ProgTemp

### List of factors

* VPH - 1, 2, 3
* camera - 'red', 'blue'
* resolution - 'LowRes', 'HighRes'
* mode - 'MOS', 'LIFU', 'mIFU'
* Binning 
* ExpMJD
* OBStartMJD
* OBTitle


## Rules for development
Since this package is intended for wide use within WL, please use the [git flow](https://jeffkreeftmeijer.com/git-flow/) methods.
This keeps the stable production level code away from new unstable features, and it means people can rely on that stability.
The WEAVE data structure is likely to change in small ways and so git flow is well suited to handle this.

There are 3 main branches:

* Release - Static versions of the code base that will never change.
* Master - production level code: the most up to date version of the code base - should be well tested
* Develop - pre-production level code: where all the different contributions are unified and tested before being signed off.

Also, Feature branches: Where your own innovations happen

Example:
0. Install git flow: https://github.com/nvie/gitflow/wiki/Installation
1. Fork [WEAVE-LOFAR/weave-io](https://github.com/WEAVE-LOFAR/weave-io) to your own account
2. Clone your version: `git clone USER/weave-io.git && git flow init -d`
3. Make a new feature/change/fix:
    * New branch `git flow feature start my_fancy_feature`
    * Do the work
    * Commit changes: `git add file1 file2 && git commit -m "description"`
    * Commit more changes: `git add file1 file2 && git commit -m "description 2"`
    * Push to your github account: `git flow feature publish my_fancy_feature`
    * Make a pull request to [WEAVE-LOFAR/weave-io](https://github.com/WEAVE-LOFAR/QAG/compare/): 
4. Dicussion
5. Feature is merged into `develop` (to combine it with all the other features)
6. Further discussion
7. Merge in `master` for common use. Master should always be the most up to date and tested branch. 
Users should be able to install and use immediately.
![](https://blog.axosoft.com/wp-content/uploads/2018/03/FlowChart-701x1024.png)