import inspect
import sys

from weaveio.hierarchy import Indexed, Multiple, Hierarchy, OneOf, Optional
from weaveio.opr3.hierarchy import SourcedData, Spectrum, Author, APS, Measurement, \
    Single, FibreTarget, Exposure, OBStack, OB, Superstack, \
    OBSpec, Supertarget, WeaveTarget, _predicate
from weaveio.opr3.l1 import L1SpectrumRow, L1SingleSpectrum, L1OBStackSpectrum, L1SupertargetSpectrum


class L2(SourcedData):
    is_template = True



class IngestedSpectrum(Spectrum):
    """
    An ingested spectrum is one which is a slightly modified version of an L1 spectrum
    """
    singular_name = 'ingested_spectrum'
    plural_name = 'ingested_spectra'
    factors = ['sourcefile', 'hduname', 'nrow', 'restframe']
    identifier_builder = ['sourcefile', 'hduname', 'nrow']
    parents = [L1SpectrumRow, APS]
    products = {'flux': Indexed('*_spectra', 'flux'), 'ivar': Indexed('*_spectra', 'ivar'), 'lambda': Indexed('*_spectra', 'lambda')}


class CombinedSpectrum(IngestedSpectrum):
    """
    A combined spectrum is one which is a slightly modified version of two L1 spectra,
    which have been joined together
    """
    singular_name = 'combined_spectrum'
    plural_name = 'combined_spectra'
    parents = [Multiple(L1SpectrumRow, 2), APS]


class FittingSoftware(Author):
    factors = ['version', 'name']
    identifier_builder = ['version', 'name']


class Fit(Hierarchy):
    """
    A fit is the result of applying fitting_software to an ingested spectrum
    In the case of combined spectra being available, there is only one ingested spectrum input
    otherwise, there are more.
    """
    is_template = True
    parents = [Multiple(IngestedSpectrum, 1, 3) , FittingSoftware]
    identifier_builder = ['fitting_software', 'ingested_spectra']


class L2ModelSpectrum(Spectrum, L2):
    is_template = True
    factors = ['sourcefile', 'hduname', 'nrow']
    identifier_builder = ['sourcefile', 'hduname', 'nrow']
    parents = [Fit, Multiple(IngestedSpectrum, 1, 3)]


class L2SpectrumLogLam(L2ModelSpectrum):
    products = {'flux': Indexed('*_spectra', 'flux'), 'err': Indexed('*_spectra', 'err'),
                'model': Indexed('*_spectra', 'model'), 'goodpix': Indexed('*_spectra', 'goodpix'),
                'loglambda': Indexed('*_spectra', 'loglam')}


class GandalfL2Spectrum(L2SpectrumLogLam):
    products = {
        'flux': Indexed('*_spectra', 'flux'), 'err': Indexed('*_spectra', 'err'),
        'flux_clean': Indexed('*_spectra', 'flux_clean'), 'model_clean': Indexed('*_spectra', 'model_clean'),
        'emission': Indexed('*spectra', 'emission'),
        'model': Indexed('*_spectra', 'model'), 'goodpix': Indexed('*_spectra', 'goodpix'),
        'loglambda': Indexed('*_spectra', 'loglam')
    }


class MCMCMeasurement(Measurement):
    is_template = True
    factors = Measurement.factors + ['formal_error']


class Line(Measurement):
    is_template = True
    factors = ['name', 'wvl', 'aon', 'vaccum']
    children = Measurement.from_names('flux', 'redshift', 'sigma', 'ebmv', 'amp')
    indexes = ['name', 'wvl']


class SpectralIndex(Measurement):
    is_template = True


class RedshiftMeasurement(Measurement):
    is_template = True
    factors = Measurement.factors + ['warn']


class RedrockTemplate(Fit):
    is_template = True
    parents = Fit.parents
    factors = ['redshifts', 'chi2s']


class RedrockFit(Fit):
    factors = Fit.factors + ['flag', 'class', 'subclass', 'snr', 'best_chi2', 'deltachi2', 'ncoeff', 'coeff',
                             'npixels', 'srvy_class']
    children = RedrockTemplate.from_names('galaxy', 'qso', 'star_a', 'star_b', 'star_cv',
                                 'star_f', 'star_g', 'star_k', 'star_m', 'star_wd')
    children += [L2ModelSpectrum, RedshiftMeasurement.from_name('best_redshift')]


class RVSpecFit(Fit):
    factors = Fit.factors + ['skewness', 'kurtosis', 'vsini', 'snr', 'chi2_tot']
    children = Measurement.from_names('vrad', 'logg', 'teff', 'feh', 'alpha')


class FerreFit(Fit):
    factors = Fit.factors + ['snr', 'chi2_tot', 'flag']
    children = Measurement.from_names('micro', 'logg', 'teff', 'feh', 'alpha', 'elem')


class GandalfFit(Fit):
    children = [Multiple(Line), Multiple(SpectralIndex), Measurement.from_name('zcorr')]
    factors = Fit.factors + ['fwhm_flag']


class PPXFFit(Fit):
    children = MCMCMeasurement.from_names('v', 'sigma', 'h3', 'h4', 'h5', 'h6')


class L2Product(L2):
    is_template = True
    parents = [OneOf(IngestedSpectrum, idname='red'), OneOf(IngestedSpectrum, idname='blue')]# (CombinedSpectrum, idname='combined')]
    children = [RedrockFit, RVSpecFit, FerreFit, GandalfFit, PPXFFit]


class L2Single(L2Product, Single):
    """
    An L2 data product resulting from two or sometimes three single L1 spectra.
    The L2 data products contain information generated by APS namely redshifts, emission line properties and model spectra.
    """
    singular_name = 'l2single'
    parents = [Multiple(L1SingleSpectrum, 2, 3, constrain=(FibreTarget, Exposure)), APS]


class L2OBStack(L2Product, OBStack):
    """
    An L2 data product resulting from two or sometimes three stacked/single L1 spectra.
    The L2 data products contain information generated by APS namely redshifts, emission line properties and model spectra.
    """
    singular_name = 'l2obstack'
    parents = [Multiple(L1OBStackSpectrum, 2, 3, constrain=(FibreTarget, OB)), APS]


class L2SuperStack(L2Product, Superstack):
    """
    An L2 data product resulting from two or sometimes three super-stacked/stacked/single L1 spectra.
    The L2 data products contain information generated by APS namely redshifts, emission line properties and model spectra.
    """
    singular_name = 'l2superstack'
    parents = [Multiple(L1SpectrumRow, 2, 3, constrain=(FibreTarget, OBSpec)), APS]


class L2SuperTarget(L2Product, Supertarget):
    """
    An L2 data product resulting from two or sometimes three supertarget L1 spectra.
    The L2 data products contain information generated by APS namely redshifts, emission line properties and model spectra.
    """
    singular_name = 'l2supertarget'
    parents = [Multiple(L1SupertargetSpectrum, 2, 3, constrain=(WeaveTarget,)), APS]


hierarchies = [i[-1] for i in inspect.getmembers(sys.modules[__name__], _predicate)]